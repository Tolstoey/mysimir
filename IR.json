{"README.md":"","custom.ts":"// MakeCode blocks for Infrared\n// Original Code by 劉正吉 https://github.com/lioujj/pxt-IR\n// MIT License\n// Changes for Calliope Mini by M. Klein\n//\n//% weight=0 color=#87bc4b icon=\"\\uf1eb\" block=\"Infrarot IR\"\nnamespace IR {\n    export enum encodingType {\n        //% block=\"NEC\"\n        NEC,\n        //% block=\"SONY\"\n        SONY\n    }\n    let tempHandler: Action;\n    let irLed = AnalogPin.C16; // P16 -> C16 Änderung für Calliope Mini\n    const pwmPeriod = 26;\n    pins.analogWritePin(irLed, 0);\n    pins.analogSetPeriod(irLed, pwmPeriod);\n    let send_init = false;\n    let rec_init = false;\n    let arr: number[] = [];\n    let received = false;\n    let first = true;\n    let rec_Type = \"\";\n    let messageStr = \"\";\n    let recPin = DigitalPin.C17 // P8 -> C17 Änderung für Calliope Mini\n    let thereIsHandler = false;\n    arr = [];\n\n    function transmitBit(highTime: number, lowTime: number): void {\n        pins.analogWritePin(irLed, 512);\n        control.waitMicros(highTime);\n        pins.analogWritePin(irLed, 0);\n        control.waitMicros(lowTime);\n    }\n\n    /**\n     *  set the infrared LED pin.\n     */\n    //% blockId=setIR_pin block=\"IR Sender an Pin %myPin\" blockExternalInputs=false\n    //% weight=90 blockGap=10\n    //% myPin.fieldEditor=\"gridpicker\" myPin.fieldOptions.columns=4\n    //% myPin.fieldOptions.tooltips=\"false\" myPin.fieldOptions.width=\"300\"\n    export function setIR_pin(myPin: AnalogPin) {\n        irLed = myPin;\n        pins.analogWritePin(irLed, 0);\n        pins.analogSetPeriod(irLed, pwmPeriod);\n        send_init = true;\n    }\n\n    /**\n     *  set the IR receiver pin.\n     */\n    //% blockId=setREC_pin block=\"Infrarotempfänger an Pin %myPin\" blockExternalInputs=false\n    //% weight=85 blockGap=10\n    //% myPin.fieldEditor=\"gridpicker\" myPin.fieldOptions.columns=4\n    //% myPin.fieldOptions.tooltips=\"false\" myPin.fieldOptions.width=\"300\"\n    export function setREC_pin(myPin: DigitalPin) {\n        recPin = myPin;\n        pins.setEvents(recPin, PinEventType.Pulse)\n        pins.setPull(recPin, PinPullMode.PullUp)\n        pins.onPulsed(recPin, PulseValue.Low, function () {\n            arr.push(input.runningTimeMicros())\n        })\n        pins.onPulsed(recPin, PulseValue.High, function () {\n            arr.push(input.runningTimeMicros())\n        })\n        control.onEvent(recPin, DAL.MICROBIT_PIN_EVENT_ON_TOUCH, tempHandler);\n        rec_init = true;\n        control.inBackground(function () {\n            basic.forever (function () {\n                if ((!received) && (rec_init)) {\n                    if (arr.length > 20) {\n                        if ((input.runningTimeMicros() - arr[arr.length - 1]) > 120000) {\n                            if (first) {\n                                resetReceiver()\n                                first = false\n                            } else {\n                                received = true\n                                decodeIR();\n                            }\n                        }\n                    }\n                }\n            })\n        })\n    }\n\n    /**\n     * send message from IR LED. You must set the message encoding type, send how many times, and the message.\n     */\n    //% blockId=sendMyMessage1 block=\"sende IR-Code %msg| ,%times| mal, mit der Codierung %myType\"\n    //% weight=80 blockGap=10\n    export function sendMyMessage1(msg: string, times: number, myType: encodingType): void {\n        if (send_init) {\n            //control.inBackground(() => {\n            sendMessage(convertHexStrToNum(msg), times, myType);\n            //})\n        }\n    }\n    /**\n         * simulate received message You must set the message encoding type, and the message.\n         */\n    //% blockId=simRecMessage block=\" simulate received NEC message IR-Code %msg\"\n    //% weight=80 blockGap=10\n    export function simRecMessage(msg: string): void {\n        arr = [];\n        let myNum = convertHexStrToNum(msg);\n        sendNEC(myNum, 1);\n        // function sendNEC(message: number, times: number): void {\n            const enum NEC {\n                startHigh = 9000,\n                startLow = 4500,\n                stopHigh = 560,\n                stopLow = 0,\n                trueHigh = 560,\n                trueLow = 1690,\n                falseHigh = 560,\n                falseLow = 560,\n                interval = 110000\n            }\n            //let address = Math.idiv(message, 0x010000)\n            let address = myNum >> 16;\n            let command = myNum % 0x010000;\n            const MESSAGE_BITS = 16;\n            let startTime = input.runningTimeMicros();\n            arr.push(startTime);\n            startTime += NEC.startHigh;\n            arr.push(startTime);\n            startTime += NEC.startLow;\n            arr.push(startTime);\n            //    transmitBit(NEC.startHigh, NEC.startLow);\n            // function encode(myCode: number, bits: number, trueHigh: number, trueLow: number, falseHigh: number, falseLow: number): void {\n            // const MESSAGE_BITS = bits;\n            let myCode = address;\n            for (let mask = 1 << (MESSAGE_BITS - 1); mask > 0; mask >>= 1) {\n                if (myCode & mask) {\n                    startTime += NEC.trueHigh;\n                    arr.push(startTime);\n                    startTime += NEC.trueLow;\n                    arr.push(startTime);\n                    // transmitBit(trueHigh, trueLow);\n                } else {\n                    startTime += NEC.falseHigh;\n                    arr.push(startTime);\n                    startTime += NEC.falseLow;\n                    arr.push(startTime);\n                    // transmitBit(falseHigh, falseLow);\n                }\n            //}\n            }\n            //    encode(address, 16, NEC.trueHigh, NEC.trueLow, NEC.falseHigh, NEC.falseLow);\n            myCode = command;\n            for (let mask = 1 << (MESSAGE_BITS - 1); mask > 0; mask >>= 1) {\n                if (myCode & mask) {\n                    startTime += NEC.trueHigh;\n                    arr.push(startTime);\n                    startTime += NEC.trueLow;\n                    arr.push(startTime);\n                    // transmitBit(trueHigh, trueLow);\n                } else {\n                    startTime += NEC.falseHigh;\n                    arr.push(startTime);\n                    startTime += NEC.falseLow;\n                    arr.push(startTime);\n                    // transmitBit(falseHigh, falseLow);\n                }\n            }\n            // encode(command, 16, NEC.trueHigh, NEC.trueLow, NEC.falseHigh, NEC.falseLow);\n                startTime += NEC.stopHigh;\n                arr.push(startTime);\n                startTime += NEC.stopLow;\n            //    transmitBit(NEC.stopHigh, NEC.stopLow);\n        //}\n        }\n\n    /**\n     * send message from IR LED. You must set the message encoding type, send how many times, and the message.\n     */\n    //% blockId=sendMyMessage2 block=\"sende IR-Code %msg| ,%times| mal, mit der Codierung %myType\"\n    //% weight=75 blockGap=10\n    export function sendMyMessage2(msg: string, times: number, myType: string): void {\n        if (send_init) {\n            if (myType == \"NEC\") {\n                sendMessage(convertHexStrToNum(msg), times, encodingType.NEC);\n            } else if (myType == \"SONY\") {\n                sendMessage(convertHexStrToNum(msg), times, encodingType.SONY);\n            }\n        }\n    }\n\n\n    function encode(myCode: number, bits: number, trueHigh: number, trueLow: number, falseHigh: number, falseLow: number): void {\n        const MESSAGE_BITS = bits;\n        for (let mask = 1 << (MESSAGE_BITS - 1); mask > 0; mask >>= 1) {\n            if (myCode & mask) {\n                transmitBit(trueHigh, trueLow);\n            } else {\n                transmitBit(falseHigh, falseLow);\n            }\n        }\n    }\n\n    function sendNEC(message: number, times: number): void {\n        const enum NEC {\n            startHigh = 9000,\n            startLow = 4500,\n            stopHigh = 560,\n            stopLow = 0,\n            trueHigh = 560,\n            trueLow = 1690,\n            falseHigh = 560,\n            falseLow = 560,\n            interval = 110000\n        }\n        //let address = Math.idiv(message, 0x010000)\n        let address = message >> 16;\n        let command = message % 0x010000;\n        const MESSAGE_BITS = 16;\n        let startTime = 0;\n        let betweenTime = 0;\n        for (let sendCount = 0; sendCount < times; sendCount++) {\n            startTime = input.runningTimeMicros();\n            transmitBit(NEC.startHigh, NEC.startLow);\n            encode(address, 16, NEC.trueHigh, NEC.trueLow, NEC.falseHigh, NEC.falseLow);\n            encode(command, 16, NEC.trueHigh, NEC.trueLow, NEC.falseHigh, NEC.falseLow);\n            transmitBit(NEC.stopHigh, NEC.stopLow);\n            betweenTime = input.runningTimeMicros() - startTime\n            if (times > 0)\n                control.waitMicros(NEC.interval - betweenTime);\n        }\n    }\n\n    function sendSONY(message: number, times: number): void {\n        const enum SONY {\n            startHigh = 2300,\n            startLow = 500,\n            trueHigh = 1100,\n            trueLow = 500,\n            falseHigh = 500,\n            falseLow = 500,\n            interval = 45000\n        }\n        const MESSAGE_BITS = 12;\n        let startTime = 0;\n        let betweenTime = 0;\n        for (let sendCount = 0; sendCount < times; sendCount++) {\n            startTime = input.runningTimeMicros();\n            transmitBit(SONY.startHigh, SONY.startLow);\n            encode(message, 12, SONY.trueHigh, SONY.trueLow, SONY.falseHigh, SONY.falseLow);\n            betweenTime = input.runningTimeMicros() - startTime\n            if (times > 0)\n                control.waitMicros(SONY.interval - betweenTime);\n        }\n    }\n\n    export function sendMessage(message: number, times: number, myType: encodingType): void {\n        switch (myType) {\n            case encodingType.NEC: sendNEC(message, times);\n            case encodingType.SONY: sendSONY(message, times);\n            default: sendNEC(message, times);\n        }\n    }\n\n    function convertHexStrToNum(myMsg: string): number {\n        let myNum = 0\n        for (let i = 0; i < myMsg.length; i++) {\n            if ((myMsg.charCodeAt(i) > 47) && (myMsg.charCodeAt(i) < 58)) {\n                myNum += (myMsg.charCodeAt(i) - 48) * (16 ** (myMsg.length - 1 - i))\n            } else if ((myMsg.charCodeAt(i) > 96) && (myMsg.charCodeAt(i) < 103)) {\n                myNum += (myMsg.charCodeAt(i) - 87) * (16 ** (myMsg.length - 1 - i))\n            } else if ((myMsg.charCodeAt(i) > 64) && (myMsg.charCodeAt(i) < 71)) {\n                myNum += (myMsg.charCodeAt(i) - 55) * (16 ** (myMsg.length - 1 - i))\n            } else {\n                myNum = 0\n                break\n            }\n        }\n        return myNum\n    }\n\n    //------------------receiver-------------\n\n    function resetReceiver() {\n        arr = []\n        received = false\n    }\n\n\n    function decodeIR() {\n        let addr = 0\n        let command = 0\n        messageStr = \"\"\n        rec_Type = \"\"\n        for (let i = 0; i <= arr.length - 1 - 1; i++) {\n            arr[i] = arr[i + 1] - arr[i]\n        }\n        if (((arr[0] + arr[1]) > 13000) && ((arr[0] + arr[1]) < 14000)) {\n            rec_Type = \"NEC\"\n            arr.removeAt(1)\n            arr.removeAt(0)\n            addr = pulseToDigit(0, 15, 1600)\n            command = pulseToDigit(16, 31, 1600)\n            messageStr = convertNumToHexStr(addr, 4) + convertNumToHexStr(command, 4)\n            arr = [];\n            if (thereIsHandler) {\n                tempHandler();\n            }\n        } else if (((arr[0] + arr[1]) > 2600) && ((arr[0] + arr[1]) < 3200)) {\n            rec_Type = \"SONY\"\n            arr.removeAt(1)\n            arr.removeAt(0)\n            command = pulseToDigit(0, 11, 1300)\n            messageStr = convertNumToHexStr(command, 3)\n            arr = [];\n            if (thereIsHandler) {\n                tempHandler();\n            }\n        }\n        resetReceiver();\n    }\n\n    function pulseToDigit(beginBit: number, endBit: number, duration: number): number {\n        let myNum = 0\n        for (let i = beginBit; i <= endBit; i++) {\n            myNum <<= 1\n            if ((arr[i * 2] + arr[i * 2 + 1]) < duration) {\n                myNum += 0\n            } else {\n                myNum += 1\n            }\n        }\n        return myNum\n    }\n\n    function convertNumToHexStr(myNum: number, digits: number): string {\n        let tempDiv = 0\n        let tempMod = 0\n        let myStr = \"\"\n        tempDiv = myNum\n        while (tempDiv > 0) {\n            tempMod = tempDiv % 16\n            if (tempMod > 9) {\n                myStr = String.fromCharCode(tempMod - 10 + 97) + myStr\n            } else {\n                myStr = tempMod + myStr\n            }\n            tempDiv = tempDiv / 16  // Math.idiv(tempDiv, 16) geändert wegen Calliope V0-Core\n        }\n        while (myStr.length != digits) {\n            myStr = \"0\" + myStr\n        }\n        return myStr\n    }\n\n    /**\n     * Do something when a receive IR\n     */\n    //% blockId=onReceivedIR block=\"wenn IR Code empfangen\" blockInlineInputs=true\n    //% weight=70 blockGap=10\n    export function onReceivedIR(handler: Action): void {\n        tempHandler = handler\n        thereIsHandler = true\n    }\n\n    /**\n     * return the encoding type of the received IR \n     */\n    //% blockId=getRecType block=\"die empfangene IR Codierung\"\n    //% weight=60 blockGap=10\n    export function getRecType(): string {\n        return rec_Type\n    }\n\n    /**\n     * return the message of the received IR \n     */\n    //% blockId=getMessage block=\"die empfangene IR Nachricht\"\n    //% weight=60 blockGap=10\n    export function getMessage(): string {\n        return messageStr\n    }\n\n}\n","main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block></xml>","main.ts":"\n","pxt.json":"{\n    \"name\": \"IR\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"v3\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"custom.ts\"\n    ],\n    \"targetVersions\": {\n        \"branch\": \"v7.0.3\",\n        \"tag\": \"v7.0.3\",\n        \"commits\": \"https://github.com/microsoft/pxt-calliope/commits/283622410ab91b26f46d68145d9ea311cb8e91dd\",\n        \"target\": \"7.0.3\",\n        \"pxt\": \"10.2.39\"\n    },\n    \"preferredEditor\": \"tsprj\"\n}\n"}